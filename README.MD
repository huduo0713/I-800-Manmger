# I-800 边缘设备算法管理系统

> 基于 **GoFrame v2.9.3** 框架构建的边缘设备算法管理系统，支持 MQTT 协议的云端算法下发、文件管理和数据同步功能。

## 🚀 快速开始

```bash
# 启动项目
go run .

# 访问API文档
http://127.0.0.1:8000/swagger/
```

## ⭐ 核心功能

- 🔗 **MQTT算法下发**: 支持云端通过MQTT协议下发算法文件
- 📁 **文件管理**: 自动下载、MD5校验、版本管理
- 🗃️ **数据同步**: SQLite数据库存储算法信息
- 🔄 **跨平台支持**: Windows开发、Linux部署自适应
- 📊 **完整API**: HTTP RESTful API (用户管理、算法查询)

## 🏗️ 系统架构

### 技术栈
- **框架**: GoFrame v2.9.3
- **数据库**: SQLite3 (嵌入式)
- **通信协议**: MQTT + HTTP
- **部署**: Docker + Kubernetes

### 分层架构
```
MQTT协议层 → Service业务层 → DAO数据层 → SQLite数据库
HTTP API层 → Controller控制层 → Service业务层 ↗
```

## 📁 项目结构详解

### � 核心业务层
```
internal/
├── service/              ⭐ 业务逻辑层
│   ├── mqtt.go          # MQTT通信服务
│   └── algorithm_add.go # 算法下发核心逻辑
├── controller/          📡 HTTP API控制器
│   ├── algorithm/       # 算法管理API
│   └── user/           # 用户管理API
├── dao/                💾 数据访问层 (自动生成)
├── model/              📋 数据模型层
│   ├── entity/         # 数据库表实体
│   └── do/             # 数据操作对象
└── cmd/                🚀 启动命令层
```

### 🔧 配置和部署
```
manifest/
├── config/config.yaml   # 主配置文件
├── deploy/             # K8s部署配置
└── docker/             # Docker容器化

data/
└── init.sql            # 数据库初始化脚本

hack/
├── config.yaml         # GoFrame CLI配置
└── *.mk               # 开发脚本
```

## ⚙️ 配置说明

### 主配置文件 (`manifest/config/config.yaml`)

```yaml
# 边缘设备配置
device:
  id: "edge-device-001"
  
# MQTT服务配置
mqtt:
  broker: "tcp://127.0.0.1:1883"  # 你的MQTT服务器地址
  clientId: "goframe-edge-device"
  keepAlive: 60

# 算法下载配置  
algorithm:
  downloadPath: ""  # 留空自动适配平台路径
  # Windows: ./runtime/
  # Linux: /usr/runtime/
```

### 跨平台路径自适应

- **开发环境(Windows)**: `./runtime/{algorithmId}/{md5}/`
- **生产环境(Linux)**: `/usr/runtime/{algorithmId}/{md5}/`
- **自定义路径**: 在配置文件中指定 `algorithm.downloadPath`

## 🧪 MQTT测试指南

### 1. 启动项目
```bash
go run .
```
看到如下日志表示启动成功：
```
[INFO] MQTT算法处理服务启动成功 {"deviceId":"edge-device-001","topic":"/sys/i800/edge-device-001/request"}
[INFO] swagger ui is serving at address: http://127.0.0.1:8000/swagger/
```

### 2. 使用MQTTx客户端测试

**连接配置**:
- **Host**: `127.0.0.1` (或你的MQTT服务器)
- **Port**: `1883`
- **Client ID**: 任意唯一ID

**发布算法下发请求**:
- **主题**: `/sys/i800/edge-device-001/request`
- **消息**:
```json
{
  "cmdId": "test-001",
  "version": "1.0",
  "method": "algorithm.add",
  "timestamp": "2025-09-12 17:30:00",
  "params": {
    "algorithmId": "algo-test-001",
    "algorithmName": "测试算法",
    "algorithmVersion": "v1.0.0",
    "algorithmVersionId": "version-001",
    "algorithmDataUrl": "https://httpbin.org/base64/SGVsbG8gV29ybGQ=",
    "fileSize": 12,
    "lastModifyTime": "2025-09-12 17:30:00",
    "md5": "65a8e27d8879283831b664bd8b7f0ad4"
  }
}
```

**订阅响应结果**:
- **主题**: `/sys/i800/edge-device-001/reply`
- **成功响应示例**:
```json
{
  "cmdId": "test-001",
  "version": "1.0",
  "method": "algorithm.add", 
  "timestamp": "2025-09-12 17:30:01",
  "code": 0,
  "message": "算法添加成功",
  "data": {
    "algorithmId": "algo-test-001",
    "version": "v1.0.0",
    "localPath": "./runtime/algo-test-001/65a8e27d8879283831b664bd8b7f0ad4/SGVsbG8gV29ybGQ="
  }
}
```

### 3. 验证测试结果

✅ **成功标志**:
1. **目录创建**: 项目根目录下出现 `runtime/` 文件夹
2. **文件下载**: `runtime/algo-test-001/65a8e27d8879283831b664bd8b7f0ad4/` 目录下有下载的算法文件  
3. **数据库记录**: SQLite数据库中 `algorithm` 表新增记录
4. **MQTT回复**: 收到 `code: 0` 的成功响应

## 🔍 错误码说明

| 错误码 | 说明 | 排查方法 |
|-------|------|---------|
| 0 | 成功 | - |
| 1001 | 下载失败 | 检查网络连接和URL有效性 |
| 1002 | MD5校验失败 | 确认文件完整性和MD5值正确 |
| 1003 | 文件系统错误 | 检查磁盘空间和目录权限 |
| 1004 | 数据库错误 | 查看数据库连接和表结构 |
| 1005 | 参数错误 | 检查请求参数完整性 |

## 🌟 架构特点

### 1️⃣ **MQTT边缘通信架构**
- ✅ **Service层处理** - 算法下发逻辑在 `internal/service/algorithm_add.go`
- ✅ **内部通信** - MQTT协议，不暴露HTTP接口
- 🔄 **易扩展** - 后期可添加Controller层提供查询API

### 2️⃣ **跨平台文件管理**
- 🖥️ **Windows开发**: 使用 `./runtime/` 相对路径
- 🐧 **Linux部署**: 自动切换到 `/usr/runtime/` 系统路径
- ⚙️ **配置化**: 支持自定义下载路径

### 3️⃣ **完整的业务流程**
```
MQTT请求 → 参数验证 → 文件下载 → MD5校验 → 数据库同步 → MQTT响应
```

## 🐧 Linux部署指南

### 1. 构建Linux版本
```bash
# 交叉编译
GOOS=linux GOARCH=amd64 go build -o i800-manager-linux .
```

### 2. 部署到Linux服务器
```bash
# 创建部署目录
sudo mkdir -p /opt/i800-manager
sudo mkdir -p /usr/runtime
sudo chmod 755 /usr/runtime

# 上传程序和配置
scp i800-manager-linux user@server:/opt/i800-manager/
scp -r manifest/ user@server:/opt/i800-manager/
scp -r data/ user@server:/opt/i800-manager/

# 启动服务
ssh user@server "cd /opt/i800-manager && ./i800-manager-linux"
```

### 3. 配置修改
```yaml
# manifest/config/config.yaml
algorithm:
  downloadPath: "/usr/runtime"  # Linux路径
mqtt:
  broker: "tcp://your-production-mqtt-server:1883"
```

## 📖 开发指南

### 算法下发功能扩展

如需添加其他MQTT方法（如algorithm.delete），在 `internal/service/mqtt.go` 中扩展：

```go
case "algorithm.delete":
    s.handleAlgorithmDelete(&request, deviceId)
```

### 添加HTTP查询API

如需对外提供算法查询接口：

1. **创建API结构** (`api/algorithm/v1/`)
2. **实现Controller** (`internal/controller/algorithm/`)  
3. **调用Service层** 复用现有业务逻辑

### 数据库操作

使用GoFrame自动生成的DAO层：
```go
// 查询算法
algorithms, err := dao.Algorithm.Ctx(ctx).All()

// 新增算法 
_, err := dao.Algorithm.Ctx(ctx).Data(algorithmData).Insert()
```

## 🔧 故障排查

### 常见问题
1. **MQTT连接失败** - 检查配置文件中的broker地址
2. **路径权限错误** - Linux环境确保/usr/runtime目录权限
3. **下载超时** - 检查网络连接和防火墙设置
4. **MD5不匹配** - 确认文件传输完整性

### 日志监控
启动时关注这些日志：
```
[INFO] 算法下载服务初始化 {"downloadPath":"./runtime","platform":"windows"}
[INFO] MQTT服务配置 {"broker":"tcp://127.0.0.1:1883","clientId":"goframe-edge-device"}
[INFO] MQTT算法处理服务启动成功
```

---

## 🎯 测试流程总结

**是的，你的理解完全正确！** 

✅ **测试流程**：
1. **启动项目**: `go run .`
2. **MQTTx发送**: 向 `/sys/i800/edge-device-001/request` 发送algorithm.add消息
3. **验证成功**: 项目根目录出现 `runtime/` 文件夹，包含下载的算法文件
4. **检查响应**: MQTTx收到 `code: 0` 的成功回复

这就表示MQTT算法下发功能测试成功了！🎉

### 🏗️ 内部业务逻辑层 (`internal/`)

#### 🚀 命令行启动层 (`internal/cmd/`)
```
internal/cmd/
└── cmd.go              # HTTP服务器启动命令，配置路由和中间件
```

#### 🎮 控制器层 (`internal/controller/`)
```
internal/controller/
├── hello/
│   ├── hello.go              # Hello控制器基础定义
│   ├── hello_new.go          # Hello控制器构造函数
│   └── hello_v1_hello.go     # Hello v1版本具体处理逻辑
└── user/
    ├── user.go               # User控制器基础定义
    ├── user_new.go           # User控制器构造函数
    ├── user_v1_create.go     # 创建用户处理逻辑
    ├── user_v1_delete.go     # 删除用户处理逻辑
    ├── user_v1_get_list.go   # 获取用户列表处理逻辑
    ├── user_v1_get_one.go    # 获取单个用户处理逻辑
    └── user_v1_update.go     # 更新用户处理逻辑
```

**作用**:
- 处理HTTP请求路由
- 调用service层业务逻辑
- 按功能模块拆分文件，便于维护

#### 📊 数据模型层 (`internal/model/`)
```
internal/model/
├── do/user.go          # Data Object - 数据库操作对象
└── entity/user.go      # Entity - 数据库表对应的实体结构体
```

**作用**:
- **entity**: 数据库表映射的Go结构体（通过GoFrame工具自动生成）
- **do**: 数据库操作时使用的对象

#### 💾 数据访问层 (`internal/dao/`)
```
internal/dao/
├── user.go             # User数据访问对象定义
└── internal/user.go    # User数据访问内部实现
```

**作用**:
- 封装数据库CRUD操作
- 提供统一的数据访问接口

#### 📦 其他内部模块
```
internal/
├── consts/             # 常量定义
├── logic/              # 业务逻辑层
├── service/            # 服务层
└── packed/             # 资源文件打包
```

### 🚀 部署运维相关

#### 📋 部署配置 (`manifest/`)
```
manifest/
├── config/
│   └── config.yaml                 # 应用配置文件
├── deploy/kustomize/               # Kubernetes部署配置
│   ├── base/                      # 基础部署配置
│   │   ├── deployment.yaml
│   │   ├── service.yaml
│   │   └── kustomization.yaml
│   └── overlays/develop/          # 开发环境覆盖配置
│       ├── configmap.yaml
│       ├── deployment.yaml
│       └── kustomization.yaml
├── docker/                        # Docker容器化
│   ├── Dockerfile
│   └── docker.sh
├── i18n/                          # 国际化文件
└── protobuf/                      # Protocol Buffers定义
```

#### 🔧 开发工具 (`hack/`)
```
hack/
├── config.yaml         # 开发配置
├── hack-cli.mk         # CLI工具makefile
└── hack.mk             # 开发脚本makefile
```

#### 📱 静态资源 (`resource/`)
```
resource/
├── public/                        # 公共静态文件
│   ├── html/                     # HTML文件
│   ├── plugin/                   # 插件文件
│   └── resource/                 # 资源文件
│       ├── css/                  # 样式文件
│       ├── image/                # 图片资源
│       └── js/                   # JavaScript文件
└── template/                     # 模板文件
```

#### 🛠️ 工具函数 (`utility/`)
```
utility/                          # 工具函数库
```

## 🌟 架构特点

1. **🏗️ 分层架构**: 清晰的分层设计，职责分离
2. **📦 模块化设计**: 按业务模块（hello、user）组织代码
3. **🔄 版本管理**: API按版本（v1）管理，便于向后兼容
4. **🤖 自动生成**: entity和dao代码可通过GoFrame工具自动生成
5. **🐳 容器化支持**: 完整的Docker和Kubernetes部署配置
6. **📏 标准化**: 遵循GoFrame框架的项目结构规范

## 🔍 主要功能模块

### Hello模块
- `GET /hello` - 简单的Hello接口

### User模块  
- `POST /user` - 创建用户
- `GET /user` - 获取用户列表（支持年龄和状态筛选）
- `GET /user/{id}` - 获取单个用户信息
- `PUT /user/{id}` - 更新用户信息
- `DELETE /user/{id}` - 删除用户

## 📖 开发指南

1. **API接口开发流程**:
   ```
   1. 在 api/模块名/v1/ 中定义接口结构体
   2. 在 internal/controller/模块名/ 中实现控制器逻辑
   3. 在 internal/service/ 中实现业务逻辑（可选）
   4. 在 internal/dao/ 中实现数据访问逻辑
   ```

2. **数据库表生成**:
   ```bash
   # 使用GoFrame CLI工具生成entity和dao
   gf gen dao
   ```

3. **API文档更新**:
   ```bash
   # 生成OpenAPI文档
   gf gen openapi
   ```

这是一个典型的GoFrame企业级项目结构，具备良好的可扩展性、可维护性和标准化程度。